#!/usr/bin/env python3

import argparse
import http.client
import json
import socket
import sys
from datetime import datetime, timezone
from typing import List


def check_internet_connection(host="8.8.8.8", port=53):
    try:
        socket.setdefaulttimeout(5)
        socket.socket(socket.AF_INET, socket.SOCK_STREAM).connect((host, port))
        return True
    except (socket.timeout, socket.error):
        return False


def get_rate_limit(username: str):
    try:
        host = "api.github.com"
        conn = http.client.HTTPSConnection(host)

        conn.request(
            "GET",
            "/rate_limit",
            headers={"Host": host, "User-Agent": f"{username}"},
        )

        response = conn.getresponse()

        if response.status != 200:
            print(f"Error: Received {response.status} from GitHub API.")
            sys.exit(1)

        data = response.read()
        parsed_data = json.loads(data.decode("utf-8"))

        return parsed_data

    except http.client.HTTPException:
        print(
            "Error: Unable to connect to GitHub. Please check your network connection."
        )
        sys.exit(1)
    except json.JSONDecodeError:
        print("Error: Unable to parse GitHub response. Please try again.")
        sys.exit(1)


def handle_api_limit(resources: dict) -> int:
    remaining_limit = -1
    try:
        rate_date = resources.get("rate", {})
        if rate_date:
            remaining = rate_date.get("remaining")
            remaining_limit = int(remaining)

    except KeyError:
        print("Error: Invalid API response structure")
        sys.exit(1)
    except ValueError:
        print("Error: Failed to process API response")
        sys.exit(1)

    return remaining_limit


def api_limit_message(resources: dict):
    try:
        rate_data = resources.get("rate", {})
        if rate_data:
            used = rate_data.get("used")
            remaining = rate_data.get("remaining")
            limit = rate_data.get("limit")
            reset_timestamp = rate_data.get("reset")

            reset_time = datetime.fromtimestamp(
                reset_timestamp, tz=timezone.utc
            ).strftime("%Y-%m-%d %H:%M:%S UTC")

            print(f"""Overall API Rate Limit:
  Used: {used}
  Usage: {remaining}/{limit}
  Reset: {reset_time}""")
        else:
            print("Error: API Rate limit data not found")

    except KeyError:
        print("Error: Invalid API response structure")
        sys.exit(1)
    except ValueError:
        print("Error: Failed to process API response")
        sys.exit(1)


def user_activity(username: str):
    if not check_internet_connection():
        print(
            "Error: Unable to connect to GitHub. Please check your network connection."
        )
        sys.exit(1)

    if handle_api_limit(get_rate_limit(username)) < 1:
        print("Error: API rate limit exceeded. Please try again later.")
        sys.exit(1)

    try:
        host = "api.github.com"
        conn = http.client.HTTPSConnection(host)

        conn.request(
            "GET",
            f"/users/{username}/events",
            headers={"Host": host, "User-Agent": f"{username}"},
        )

        response = conn.getresponse()

        if response.status != 200:
            print(f"Error: Received {response.status} from GitHub API.")
            sys.exit(1)

        data = response.read()
        parsed_data = json.loads(data.decode("utf-8"))

        if not parsed_data:
            print(f"{username} has no recent activity.")
            sys.exit(0)

        return parsed_data

    except socket.gaierror:
        print(
            "Error: Could not resolve the hostname. Please check your network connection."
        )
        sys.exit(1)

    except json.JSONDecodeError:
        print("Error: Unable to parse GitHub response. Please try again.")
        sys.exit(1)

    except http.client.HTTPException:
        print(
            "Error: Unable to connect to GitHub. Please check your network connection."
        )
        sys.exit(1)


def event_message(event: str, commit_count: int, repo_name: str) -> str:
    if event == "PushEvent":
        if commit_count == 1:
            return f"- Pushed {commit_count} commit to {repo_name}"
        return f"- Pushed {commit_count} commits to {repo_name}"
    elif event == "PullRequestEvent":
        return f"- Opened a pull request in {repo_name}"
    elif event == "WatchEvent":
        return f"- Starred {repo_name}"
    elif event == "IssuesEvent":
        return f"- Opened a new issue in {repo_name}"
    return ""


def handle_event(event_type: str) -> str | None:
    event_type = event_type.lower()

    event_list = ["push", "pull", "watch", "issues"]

    if event_type == event_list[0]:
        return "PushEvent"
    elif event_type == event_list[1]:
        return "PullRequestEvent"
    elif event_type == event_list[2]:
        return "WatchEvent"
    elif event_type == event_list[3]:
        return "IssuesEvent"
    elif event_type not in event_list and event_type is not None:
        return "NoEvent"

    return None


def format_date(date_string):
    dt = datetime.strptime(date_string, "%Y-%m-%dT%H:%M:%SZ")
    return dt.strftime("%B %d, %Y")


def handle_response(
    parser,
    responses: list,
    user_event=None,
):
    repos = {}
    repo_dates = {}

    for response in responses:
        event_type = response.get("type")
        repo_name = response.get("repo", {}).get("name")
        event_date = response.get("created_at")

        if not repo_name:
            continue

        if repo_name not in repos:
            repos[repo_name] = {
                "PushEvent": 0,
                "PullRequestEvent": 0,
                "IssuesEvent": 0,
                "WatchEvent": 0,
            }
            repo_dates[repo_name] = event_date

        if event_type in repos[repo_name]:
            repos[repo_name][event_type] += 1

        if event_date > repo_dates[repo_name]:
            repo_dates[repo_name] = event_date

    filtered_event = handle_event(user_event) if user_event else None

    for repo_name, events in repos.items():
        latest_date = format_date(repo_dates[repo_name])
        for event_type, count in events.items():
            if event_type != "EventDate":
                event_msg = event_message(event_type, count, repo_name)

                if (event_type == filtered_event and count > 0) or (
                    filtered_event is None and count > 0
                ):
                    if event_msg:
                        print(f"{event_msg}")
                        print(f"  Latest activity: {latest_date}")
                        print()
                # TODO: check event if the specific event is empty or that specific event is count == 0

        if filtered_event == "NoEvent":
            print("Error: invalid event type")
            if parser:
                parser.print_help()
            sys.exit(0)


def main(argv: List[str]):
    parser = argparse.ArgumentParser(
        prog="github-activity",
        description=(
            "A command-line tool to retrieve and display GitHub user activity, "
            "including push events, pull requests, issues, and more. "
            "This tool is based on the Roadmap.sh Backend Project: https://roadmap.sh/projects/github-user-activity"
        ),
        add_help=False,
    )

    parser.add_argument("username", nargs="?", help="Github Username")
    parser.add_argument(
        "event",
        nargs="?",
        help="Event Type: push, pull, watch, issues, or leave empty for all activities",
    )
    parser.add_argument(
        "-l",
        "--limit",
        action="store_true",
        help="Check remaining API limit for the specified username",
    )
    parser.add_argument(
        "-v",
        "--version",
        action="version",
        version="%(prog)s 0.1",
        help="Print version",
    )
    parser.add_argument("-h", "--help", action="help", help="Print help")

    args = parser.parse_args()

    if len(argv) == 1:
        parser.print_help()
        sys.exit(0)

    if args.limit:
        if not args.username:
            print("Error: Username is required to check the API limit")
            parser.print_help()
            sys.exit(1)

        api_limit_message(get_rate_limit(args.username))
        sys.exit(0)

    if not args.username:
        print("Error: Username is required")
        parser.print_help()
        sys.exit(1)

    responses = user_activity(args.username)
    if isinstance(responses, dict):
        print("Error: Username not found")
        sys.exit(1)

    handle_response(parser, responses, args.event)


if __name__ == "__main__":
    main(sys.argv)
